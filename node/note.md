## node是什么 ?
* 提供一个可以让js 运行在服务端的一个运行时
* 底层是c++编写 性能是ok
* node是基于js核心(ecmascript) 系统级别的api
    文件操作 网络编程 实现自己的web服务
 
## node解决了什么问题
 web服务器的瓶颈 用户的访问量
 
1. java php 用户访问服务器,每个客户连接服务器，都会产生一个新的线程，一个线程大约
占2mb的内存,8g内存

2. node的特点是不会创建新的线程，就发射一个事件

    (多线程 同步) 只要多个人需要操作同一个资源必须通过锁 真的同时执行嘛，只是轮换的时间快一些而已
    ，切换时间片也会有性能消耗，还有锁的问题
   
    多线程是搞线程池来管理的
    我预计开启20个线程，让20个线程来复用(比如，最多请求20个，再多的等等)

    优点：可以同时处理请求，大量的计算操作，cpu密集型

    node中比较适合的i/o密集型 文件的读写操作 异步的
    是通过事件驱动的方式 通知我返回结果

3. 前后端分离，写一些工具库(webpack,cli)
   
    node比较适合web应用场景 返回文件 文件读写 
    web->80 搭建中间层 java ->3000
   * 解决跨域问题
   * 数据格式化
    
## node核心特点
1. 事件驱动 node的api是基于事件的 异步的
2. 单线程(底层还是多线程) 进程(主线程) node可以开启多个进程
3. 不适合cpu密集型(压缩、计算)****__****

## 同步异步 阻塞非阻塞(针对的点不一样)
1. 同步异步 关注的消息通知的机制 
2. 阻塞非阻塞 程序等待消息结果的状态

## 全局模块 局部模块
- 必须使用 package.json 中配置的bin参数
- #! /usr/bin/env node

## npm link
就是将当前的目录临时放到全局下 方便调试

## 本地安装(--save -S / --save-dev -D)

## npm版本号管理问题
由三位组成
- MAJOR 可能不在兼容老版本了
- MINOR 小版本 比如 新增了一些兼容旧版本的api
- PATCH 修复一些bug
 npm version major min patch
  * major 主版本号+1
  * patch 每次版本的时候 最后一位+1 自动关联到git tag
  
## 版本号含义
2.2.0 写死版本
^2.2.0 限定大版本，后面更新只要不超过2就行
~2.2.0 限制了前两个版本 后面的版本只要比0大就行

>=2.0 大于这个版本
预发版本 
alpha 预览版 内部测试版
beta 测试版 公开测试版
rc 最终测试版本

## script
- 执行命令 会将当前的node_modules目录下的.bin文件夹放到全局中(所以可以直接使用 执行完就销毁了)

## npx和script基本一致
npx  安装好-> 执行完 ->删除掉 知识一个临时的使用方案
可以直接帮我们运行 .bin文件夹下的内容 
1. 如果.bin目录下存在 会执行对应脚本
2. 如果不存在，会下载运行
3. 好处 npm install create-react-app -g 每次使用都是这个版本 每次想最新 我们使用 npx create-react-app -g

   
## 源的切换 (npm nrm(切换源) nvm)
- npm install nrm -g
nrm ls / nrm use npm/cnpm/taobao

## 包的发布
1. 账号密码
2. 在官方源上发布
npm addUser -> npm publish  