/*
* 虽然有垃圾回收机制，但是，我们编写代码操作不当还是会造成内存泄漏
* 1.意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。 原因：全局变量，不会被回收。
* 2.被遗忘的定时器或者回调 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。
* 解决：手动删除定时器和dom。
* 3.子元素存在引用引起的内存泄漏
* 4. 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。
* 解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。
* https://www.cnblogs.com/yanglongbo/articles/9762359.html
*
*
* */
// 内存泄露解决举例：
//由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。
function bindEvent () {
  var obj = document.createElement('XXX')
  obj.onclick = function () {
    Ï
    //Even if it's a empty function
  }
  obj = null  //  忘记这一步 容易形成闭包
}

//当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。
