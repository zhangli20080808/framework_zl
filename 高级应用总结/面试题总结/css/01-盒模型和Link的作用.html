<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="apple-touch-icon-precomposed" sizes="114x114"
        href="apple-icon-114.png" type="image/png">
  <!-- 提前下载视频资源如下，（当然，还可以提前下载好图片等等，只需要as="image" type="image/png"）-->
  <link rel="preload" href="sintel-short.mp4" as="video" type="video/mp4">
  <link rel="stylesheet" href="https://example.com/styles.css">
  //链接到一个CSS层叠样式表

  <link rel="canonical" href="URL.html">
  //SEO优化：重定向

  <link rel="shortlink" href="https://example.com/?p=42">
  //之前用于包含icon的链接（已被废弃不再使用）

  <link rel="amphtml" href="https://example.com/path/to/amp-version.html">
  //链接到当前文档的一个 AMP HTML 版本

  <link rel="manifest" href="manifest.json">
  //链接到一个指定Web应用程序“安装”证书的JSON文件

  <link rel="author" href="humans.txt">
  //链接到文档的作者

  <link rel="license" href="copyright.html">
  //指向一个适用于链接内容的版权申明

  <link rel="alternate" href="https://es.example.com/" hreflang="es">
  //给出可能的你的另一种语言的文档位置参考

  <link rel="me" href="https://google.com/profiles/thenextweb" type="text/html">
  <link rel="me" href="mailto:599729022@qq.com">
  <link rel="me" href="sms:+599729022">
  //提供作者或其他的信息

  <link rel="archives" href="https://example.com/archives/">
  //链接到一个描述历史记录、文档或其他具有历史意义的材料的集合的文档

  <link rel="index" href="https://example.com/">
  //链接到层次结构中的顶级资源

  <link rel="self" type="application/atom+xml" href="https://example.com/atomFeed.php?page=3">
  //给出一个自我参考,当文档有多个可能的参考时非常有用

  <link rel="first" href="https://example.com/atomFeed.php">
  <link rel="next" href="https://example.com/atomFeed.php?page=4">
  <link rel="prev" href="https://example.com/atomFeed.php?page=2">
  <link rel="last" href="https://example.com/atomFeed.php?page=147">
  //分别是在一系列文件中的第一个、下一个、上一个和最后一个

  <link rel="EditURI" href="https://example.com/xmlrpc.php?rsd" type="application/rsd+xml" title="RSD">
  //当使用第三方服务来维护 blog 时使用

  <link rel="pingback" href="https://example.com/xmlrpc.php">
  //当另一个 WordPress 博客链接到你的 WordPress 博客或文章时形成一个自动化的评论

  <link rel="webmention" href="https://example.com/webmention">
  //当你在自己的页面上链接到一个URL时通知它

  <link rel="import" href="/path/to/component.html">
  //加载一个外部的HTML文件到当前HTML文件中

  <link rel="search" href="/open-search.xml" type="application/opensearchdescription+xml" title="Search Title">
  //打开搜索

  <link rel="alternate" href="https://feeds.feedburner.com/example" type="application/rss+xml" title="RSS">
  <link rel="alternate" href="https://example.com/feed.atom" type="application/atom+xml" title="Atom 0.3">
  //Feeds

  <link rel="dns-prefetch" href="//example.com/">
  <link rel="preconnect" href="https://www.example.com/">
  <link rel="prefetch" href="https://www.example.com/">
  <link rel="prerender" href="https://example.com/">
  <link rel="preload" href="image.png" as="image">
  //预取、预载、预浏览

  <link rel="icon" href="favicon.ico" type="image/x-icon"/>
  //网页加入图标

  <link rel="Bookmark" href="favicon.ico">
  //收藏夹中显示的图标

  <link rel="canonical" href="http://example.com/article.html">
  //用于该文章的样式

  <link rel="mask-icon" href="path/to/icon.svg" color="red">
  //固定网站（Apple Safari浏览器）

  <link rel="chrome-webstore-item" href="https://chrome.google.com/webstore/detail/APP_ID">
  //禁用翻译提示（Google Chrome浏览器）

  <link rel="manifest" href="manifest.json">
  //链接到一个 manifest 并定义 manifest 的源数据
  //manifest.json 中的例子也可以通过以下链接找到（Google Chrome Mobile 针对 Android）

  <link rel="icon" sizes="192x192" href="highres-icon.png">
  //主屏幕图标（Google Chrome Mobile 针对 Android）

  <title>盒模型</title>
  <style type="text/css">
      * {
          margin: 0;
          padding: 0;
      }

      #div1 {
          position: relative;
          width: 100px;
          padding: 10px;
          border: 1px solid #ccc;
          margin: 10px;
          /*box-sizing: border-box; // 整个border里面100 内容变成78了*/
      }

      #div1 p {
          position: absolute;
          top: 0;
          left: 0;
          height: 20px;
      }

  </style>
</head>
<body>
<div id="div1">
  div干啥事干
  <p>this is div1</p>

</div>
<script>
  console.log(b)
</script>
<script>
  console.log('1')
  let div = document.getElementById('div1').offsetWidth
  let div2 = document.getElementById('div1').clientWidth
  console.log(div, div2)
</script>

<!--
如何理解语义化？
可读 ，比较友好 我全部 使用div也能实现相同的效果
我们的代码不是给我看 而是给机器看 比如搜索引擎 就很容易分析出网页上的一些关系 ，通过正确的搜索结果返回回来
好处？
1. 让人更容易读懂(增加代码可读性)
2. 让搜索引擎更容易读懂(seo)


行内元素 display:inline/inline-block span img input button
块级元素 display:block/table  div h1 h2 p table ul ol

盒模型
W3C盒子模型 box-sizing: content-box  元素的宽高大小表现为内容的大小
IE盒子模型 box-sizing: border-box 元素的宽高表现为内容 + 内边距 + 边框的大

link的rel属性有很多的值，不同的值代表了外部资源与本html文档的关系。

1. 连接外部的样式表，这个是最常用的
<link rel="stylesheet" type="text/css" href="*.css"/>指被link链接的css文档是本文档的样式描述文件。

2.链接一个外部的icon用于浏览器的栏目图标和收藏夹图标,地址栏最前面的小图标和收藏夹图标 <link rel="icon" href="/favicon.ico" >

是对于IOS的图标，icon属性无效，需使用 apple-touch-icon and apple-touch-startup-image 。

另外rel="icon" 同时可以附加sizes="32x32"等属性，确保浏览器只会把目标图片解析成32x32的大小

我们可以提供多种大小的图片，浏览器会自行选择最合适的图片。
<link rel="icon" sizes="16x16" href="/favicon.ico" >

3. rel="author license",规定一些作者和版权相关的信息
4.
preconnect是告知浏览器提前连接指定的url，以便在后面需要使用该连接的时候，连接已经形成，节省了时间。
prefetch是告知浏览器立刻取来url所指向的资源，这个适用于该资源立刻需要被用户使用。
preload是告知浏览器预加载一些url指定的资源，这些资源可能立刻会被使用。

通过预加载，将一些后续需要使用的资源提前下载下来，虽然会导致一开始网页加载的时候，空白一段时间，但是却可以换来后续用户使用体验的增加，使用户在操作网页的时候，不会中途因为等待资源下载而等待。

preload更加适用于预加载资源
preload可以预先加载如下这些资源， 并通过as属性指定如下这些资源类型，并通过type类型指定这些资源中的子资源，例如as="vedio" type="vedio/mp4"

DNS预解析dns-prefetch提升页面载入速度优化前端性能
当浏览器请求一个URL的时候，通过firebug我们可以发现大概有以下几个过程：阻挡、域名解析、建立连接、发送请求、等待响应、接收数据
1、阻挡：解决方案——提高浏览器并发连接数

阻挡：不同的浏览器对单个域名的最大并发连接数有一定的限制
某些URL的域名分散处理，比如我们的图片域名
比如我们的图片域名，一般用类似   A.taobao.com  的域名
包含20多张图片的时候，那至少有10几个请求会被阻挡， 如果分散到

b.taobao.com  c.taobao.com d.taobao.com/ 等不同的域名 至少这20个图片请求会并发进行，网站打开速度会明显提升很多
类似的，可以对一些css/js的域名同样处理

2. 域名解析
域名->ip 一般都很快 但也会有延迟 一般浏览器会对解析结果进行缓存，对新域名进行预解析 但并不是所有的浏览器都会进行预解析
为了帮助浏览器对 某些域名进行预解析 可以在页面中添加link rel 添加 dns-prefetch 告诉浏览器对指定域名进行预解析
//tce.alicdn.com
//img.alicdn.com
//g.alicdn.com

3. cookie污染
怎么理解呢？
那就是为什么用img0.tbcdn.cn这个域名，而不是img0.taobao.com呢？
如果用后面的域名 每次请求图片都会带上长长的 cookie 导致 网络速度变慢，浪费带宽，而淘宝图片服务器并不需要这些cookie

4. DNS预解析解决方案
DNS预解析是浏览器试图在用户访问链接之前解析域名，这是计算机的正常DNS解析机制。

域名解析后，如果用户确实访问该域名，那么DNS解析时间将不会有延迟。

例子？
DNS预解析在某个页面中包含非常多的域名非常有效
遇到网页中的超链接，DNS prefetching从中提取域名并将其解析为IP地址，
这些工作在用户浏览网页时，使用最少的CPU和网络在后台进行解析。

当用户点击这些已经预解析的域名，可以平均减少200毫秒耗时


DNS Prefetch，即DNS预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点：
　一个是减少DNS的请求次数，
　另一个就是进行DNS预获取 。

DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验

浏览器对网站第一次的域名DNS解析查找流程依次为：浏览器缓存——系统缓存——路由器缓存——ISP DNS缓存——递归搜索

默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch

DNS Prefetch 应该尽量的放在网页的前面，推荐放在 <meta charset="UTF-8"> 后面


预解析的实现：
1、用meta信息来告知浏览器, 当前页面要做DNS预解析:<meta http-equiv="x-dns-prefetch-control" content="on" />

2、在页面header中使用link标签来强制对DNS预解析: <link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />

3. dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。

需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用DNS 预读取能节省每月100亿的DNS查询 。

　如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：
<meta http-equiv="x-dns-prefetch-control" content="off">

-->
</body>
</html>
