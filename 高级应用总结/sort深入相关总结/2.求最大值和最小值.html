<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>获取数组中最大值和最小值</title>
</head>
<body>
<script>
    const ary = [1, 2, 5, 54, 7, 12, 22];

    //1.冒泡排序
    //2.sort方法排序
    //3.Math.max()   注意使用 eval   Math.min 一个一个将比较的数传入，这样才能得到最后的结果，直接放入一个数组是不行的
    //4.Math.max(ary.join(","));
    //console.log(Math.max(eval(ary.join(","))));最后一个值
    // ary.sort(function (a, b) {
    //     return a - b;
    // })
    //console.log(ary[ary.length-1])

    Math.max.apply(null,ary);
    //正确:Math.max(1,2,5,54,7,12,22);

    var str = ary.join(",");//"1,2,5,54,7,12,22"
    Math.max("1,2,5,54,7,12,22");//NaN  直接传入 错误

    //eval(ary.join(","))//将字符串转换成js表达式
    //括号表达式:如果有多项,总是返回最后一项

    // const obj = {name: 'zl', fn: fn2}

    //(1,2,5,54,7,12,22) //22
    //(function fn1(){console.log(1)},function fn2(){console.log(2)});
    //(function(){console.log(1)})()
    // !(fn1, fn2)() 只输出fn2 (x1,x2,x3)括号表达式，一个括号中出现多项内容，中间用','隔开，但是最后我们只获取到最后一项
    // (fn1,obj.fn)()   执行的是obj.fn 但是执行的时候 里面的this变成了window 而不是  obj
    //假设法 假设第一项是最大的值,依次和后面的项进行比较,如果后面有一项值比我假设的值大的话,说明假设错了,再重新设置假设的值


    const test = eval("  Math.max(" + ary.toString() + ")")  //54

    // 和自定义属性一样  都是js中最常用的 编程思想 比如我们的数组去重
    // var ary = [1, 2, 5, 54, 7, 12, 22];
    // var curMax = ary[0];
    // var curMin = ary[0];
    // for (var i = 0; i < ary.length; i++) {
    //     ary[i + 1] > curMax ? curMax = ary[i + 1] : null;
    //     ary[i + 1] < curMin ? curMin = ary[i + 1] : null;
    // }


    let curMax = ary[0]
    let curMin = ary[0]
    for (let i = 0; i < ary.length; i++) {
        ary[i + 1] > curMax ? curMax = ary[i + 1] : null
        ary[i + 1] > curMin ? curMin = ary[i + 1] : null
    }
</script>
</body>
</html>


